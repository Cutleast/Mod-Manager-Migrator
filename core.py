from main import MainApp
import msgpack
import os
import winreg
import shutil
from fnmatch import fnmatch


# Create class for modding instance ##################################
class ModInstance:
    """
    General class for mod manager instances.
    """

    def __init__(self, app: MainApp, instance: dict):
        self.app = app
        self.instance = instance
        self.name = instance.get('name', "")
        self.mods = instance.get('mods', [])
        self.paths = instance.get('paths', {})
        self.loadorder = []
        self.size = 0
    
    def __repr__(self):
        return "ModInstance"
    
    def get_loadorder(self):
        """
        Returns loadorder.
        """

        return self.mods
    
    def create_instance(self):
        """
        Create instance. Steps depend on mod manager.
        """

        return
    
    def get_size(self):
        """
        Calculates total size in bytes of instance files.
        """

        return self.size
    
    def import_mod(self, folder: str):
        return


# Create class for Vortex stagefiles #################################
class StageFile:
    def __init__(self, path: str):
        self.path = path
        self.data = {}
        self.files = []
        self.mods = []
        self.modfiles = {} # mod: files
    
    def parse_file(self):
        with open(self.path, 'rb') as file:
            data = msgpack.load(file)
        
        self.data = data
        self.files = [file['relPath'] for file in self.data['files']]
    
    def get_modlist(self):
        mods = []
        modfiles = {}
        for file in self.data['files']:
            mod = os.path.join(os.path.dirname(self.path), file['source'])
            if mod not in mods:
                mods.append(mod)
            if modfiles.get(mod, None) is None:
                modfiles[mod] = [os.path.normpath(file['relPath'])]
            else:
                modfiles[mod].append(os.path.normpath(file['relPath']))
        self.mods = mods
        self.modfiles = modfiles
    
    def if_from_mod(self, file: str, mod: str):
        filepath = os.path.normpath(file.split(mod)[1]).strip("\\".strip())
        return filepath in self.modfiles[mod]
    
    def get_mod_by_file(self, path: str):
        path = path.split(os.path.dirname(self.path))[1].strip("\\")
        modname, path = path.split("\\", 1)
        for mod, files in self.modfiles.items():
            if os.path.basename(mod) == modname:
                continue
            elif path in files:
                return os.path.basename(mod)
        else:
            #print(f"{path = }")
            #print(f"{mod = }")
            #print(path in files)
            #print(files)
            return modname
            raise ValueError(f"File '{path}' not found!")
    

# Create class for Vortex instance ###################################
class VortexInstance(ModInstance):
    """
    Class for Vortex ModInstance. Inherited from ModInstance class.
    """

    def __init__(self, app: MainApp, instance: dict):
        super().__init__(app, instance)
        
        self.stagefile = StageFile(self.paths['stagefile'])
        self.stagefile.parse_file()
        self.stagefile.get_modlist()
        self.mods = self.instance['mods'] = self.stagefile.mods
        self.files = self.instance['files'] = self.stagefile.files
        self.unsorted_loadorder = True

    def __repr__(self):
        return "VortexInstance"
            
    def sort_loadorder(self):
        """
        Creates loadorder from Vortex stagefile.
        """

        self.app.log.info(f"Creating loadorder with {len(self.mods)} mod(s) from stagefile...")
            
        # Write unsorted loadorder for debbuging purpose to appdata folder
        with open(os.path.join(os.getenv('APPDATA'), self.app.name, 'unsorted_loadorder.txt'), 'w') as file:
            mods = ""
            for mod in self.stagefile.mods:
                mods += "\n" + os.path.basename(mod)
            #mods = mods.strip()
            file.write(f"# This file was automatically generated by Mod Manager Migrator.{mods}")
        
        # Scan mods
        self.app.log.info("Scanning mods...")
        load_order = [os.path.basename(mod) for mod in self.stagefile.mods]
        for c, mod in enumerate(self.stagefile.mods):
            modname = os.path.basename(mod)
            self.app.log.debug(f"Scanning mod '{modname}'... ({c}/{len(self.stagefile.mods)})")
            files = create_folder_list(mod)
            #self.app.log.debug(f"Files: {len(files)}")
            # Create list of mods that overwrite this
            overwriting_mods = []
            for file in files:
                if not self.stagefile.if_from_mod(file, mod):
                    overwriting_mod = self.stagefile.get_mod_by_file(file)
                    if overwriting_mod != modname:
                        overwriting_mods.append(overwriting_mod)
            overwriting_mods = list(set(overwriting_mods)) # Remove duplicates
            if overwriting_mods:
                self.app.log.debug(f"Mod '{modname}' gets overwritten by {overwriting_mods}")

            index = load_order.index(modname)
            if overwriting_mods:
                #self.app.log.debug(f"Sorting mod...")
                self.app.log.debug(f"Old index: {index}")
                for overwriting_mod in overwriting_mods:
                    overwriting_index = load_order.index(overwriting_mod)
                    # Compare indices
                    if index > overwriting_index:
                        index = overwriting_index
                        continue
                if index < 0:
                    index = 0
                self.app.log.debug(f"New index: {index}")

            # Move mod to new index
            load_order.remove(modname)
            load_order.insert(index, modname)
        
        self.app.log.info("Created load order from Vortex deployment file.")
        
        # Write sorted loadorder for debbuging purposes to appdata folder
        with open(os.path.join(os.getenv('APPDATA'), self.app.name, 'sorted_loadorder.txt'), 'w') as file:
            for mod in load_order:
                mods += "\n+" + os.path.basename(mod)
            mods = mods.strip()
            file.write(f"# This file was automatically generated by Mod Organizer.\n{mods}")
        
        load_order.reverse()
        self.loadorder = load_order
        self.unsorted_loadorder = False

        self.app.log.info(f"Created loadorder.")
    
    def get_loadorder(self):
        """
        Returns loadorder. Creates it from stagefile if not already done.
        """

        # Only sort loadorder if not already done
        if self.unsorted_loadorder:
            self.sort_loadorder()

        return super().get_loadorder()
    
    def check_loadorder(self):
        """
        This method is for checking if files in stagefile and loadorder match.
        For debugging purposes!
        """

        print("Checking loadorder...")
        print("Creating stagefile list...")
        stagefile_files = {}
        for file in self.stagefile.data['files']:
            stagefile_files[file['relPath']] = file['source']
        
        print("Creating loadorder list...")
        loadorder_files = {}
        for c, mod in enumerate(self.loadorder):
            print(f"Mod {c}/{len(self.loadorder)}")
            mod = os.path.join(os.path.dirname(self.stagefile.path))
            #files = stagefile.modfiles[mod]
            files = create_folder_list(mod)
            for file in files:
                loadorder_files[file] = os.path.basename(mod)
        
        print("Comparing...")
        different_files = {}
        # Check each file and mod
        for file, mod in stagefile_files.items():
            # If file should come from different mod, add it to list
            if loadorder_files.get(file, mod) != mod:
                different_files[file] = mod
        if different_files:
            print("Found different files:")
            print(different_files)
        else:
            print("Found no differences!")

    def get_size(self):
        self.app.log.debug(f"Calculating size of Vortex instance...")
        
        # Calculate size of staging folder
        #size = get_folder_size(self.paths['staging_folder'])
        size = 0
        for file in self.stagefile.data['files']:
            size += os.path.getsize(os.path.join(self.paths['staging_folder'], file['source'], file['relPath']))

        # Add size of download folder if one is given
        if self.paths['download_path']:
            size += get_folder_size(self.paths['download_path'])

        self.size = size
        self.app.log.debug(f"Calculation complete. Instance size: {get_size(self.size)}")
        return super().get_size()

# Create class for MO2 instance ######################################
class MO2Instance(ModInstance):
    """
    Class for ModOrganizer ModInstance. Inherited from ModInstance class.
    """

    def __repr__(self):
        return "MO2Instance"

    def create_instance(self):
        self.app.log.info(f"Creating MO2 instance '{self.name}' in '{self.paths['instance_path']}'...")

        # Create directories
        self.app.log.debug(f"Creating directories...")
        appdata_path = os.path.join(os.getenv('LOCALAPPDATA'), 'ModOrganizer', self.name)
        os.makedirs(appdata_path)
        os.makedirs(self.paths['instance_path'], exist_ok=True)
        os.makedirs(self.paths['download_path'], exist_ok=True)
        os.makedirs(self.paths['mods_path'], exist_ok=True)
        os.makedirs(self.paths['profiles_path'], exist_ok=True)
        os.makedirs(os.path.join(self.paths['profiles_path'], 'Default'), exist_ok=True)
        os.makedirs(self.paths['overwrite_path'], exist_ok=True)
        self.app.log.debug(f"Created instance folders.")

        # Create ini file with instance paths
        instance_path = self.paths['instance_path'].replace('\\', '/')
        download_path = self.paths['download_path'].replace('\\', '/')
        skyrim_path = os.path.join(get_steam_path(), 'steamapps', 'common', 'Skyrim Special Edition').replace('\\', '/')
        with open(os.path.join(appdata_path, 'ModOrganizer.ini'), 'w') as inifile:
            ini = f"""
[General]
gameName=Skyrim Special Edition
selected_profile=@ByteArray(Default)
gamePath={skyrim_path}
version=2.4.4
first_start=true

[Settings]
base_directory={instance_path}
download_directory={download_path}
style=Paper Dark.qss

[PluginPersistance]
Python%20Proxy\\tryInit=false

[recentDirectories]
size=0
""".strip()
            inifile.write(ini)
        self.app.log.debug(f"Created 'ModOrganizer.ini'.")

        # Create profile files
        prof_path = os.path.join(self.paths['profiles_path'], 'Default')
        # Create initweaks.ini
        with open(os.path.join(prof_path, 'initweaks.ini'), 'w') as inifile:
            inifile.write("""[Archive]\nbInvalidateOlderFiles=1""".strip())
        self.app.log.debug("Created 'initweaks.ini'.")

        # Create modlist.txt
        with open(os.path.join(prof_path, 'modlist.txt'), 'w') as file:
            #mods = '\n+'.join(self.loadorder).strip()
            mods = ""
            loadorder = self.loadorder.copy()
            #loadorder.reverse()
            for mod in loadorder:
                mods += "\n+" + os.path.basename(mod)
            mods = mods.strip()
            file.write(f"# This file was automatically generated by Mod Organizer.\n{mods}")
        self.app.log.debug("Created 'modlist.txt'.")

        # Copy ini files from User\Documents\My Games\Skyrim Special Edition
        #ini_path = os.path.join(self.app.doc_path, 'My Games', 'Skyrim Special Edition')
        ini_path = self.app.doc_path
        shutil.copy(os.path.join(ini_path, 'Skyrim.ini'), os.path.join(prof_path, 'skyrim.ini'))
        shutil.copy(os.path.join(ini_path, 'SkyrimCustom.ini'), os.path.join(prof_path, 'skyrimcustom.ini'))
        shutil.copy(os.path.join(ini_path, 'SkyrimPrefs.ini'), os.path.join(prof_path, 'skyrimprefs.ini'))
        self.app.log.debug("Copied ini files from Skyrim folder.")

        self.app.log.info(f"Created MO2 instance.")
    
    def import_mod(self, folder: str):
        modname = os.path.basename(folder)
        if fnmatch(modname, "*-*-*-*-*"):
            meta = modname.rsplit("-", 4)
            modid = meta[-1]
            fileid = meta[0]
        shutil.copytree(folder, os.path.join(self.paths['mods_path'], modname))
    
    def get_size(self):
        self.app.log.debug(f"Calculating size of MO2 instance...")

        # WORK IN PROGRESS!!
        # Calculate size for each instance subfolder
        # because they can be at different locations

        self.app.log.debug(f"Calculation complete. Instance size: {self.size}")

        return super().get_size()

    @staticmethod
    def get_instances(app: MainApp):
        """
        Create a list with all ModOrganizer instances at %LOCALAPPDATA%\\ModOrganizer
        """
        instances_path = os.path.join(os.getenv('LOCALAPPDATA'), 'ModOrganizer')
        instances = []
        # Check if path exists
        if os.path.isdir(instances_path):
            # Filter for folders and ignore files
            instances = [obj for obj in os.listdir(instances_path) if os.path.isdir(os.path.join(instances_path, obj))]
            app.log.info(f"Found {len(instances)} instance(s).")
        # Show error message otherwise
        else:
            app.log.error("Failed to load instances from ModOrganizer: Found no instances.")
        
        # Return list with found instances
        return instances

# Read folder and save files with relative paths to list #############
def create_folder_list(folder: str):
    """
    Creates a list with all files with relative paths.
    """

    files = []

    for root, dirs, _files in os.walk(folder):
        for f in _files:
            files.append(os.path.join(root, f))

    return files

# Define function to round bytes #####################################
def get_size(bytes: int | float, suffix="B"):
    """
    Scale bytes to their proper format; for e.g:
    1253656 => '1.20MB'
    1253656678 => '1.17GB'
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P", "H"]:
        if bytes < factor:
            if f"{bytes:.2f}".split(".")[1] == "00":
                return f"{int(bytes)}{unit}{suffix}"
            else:
                return f"{bytes:.2f}{unit}{suffix}"
        bytes /= factor
    else:
        return str(bytes)

# Define function to calculate folder size
def get_folder_size(start_path: str):
    total_size = 0
    i = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            # skip if it is symbolic link
            if not os.path.islink(fp):
                try:
                    total_size += os.path.getsize(fp)
                except Exception as ex:
                    pass
                i += 1
                #print(f"{f'''Calculating size of '{start_path}'... ({get_size(total_size)})''':100}", end='\r')
    return total_size

# Define function get Steam installation path from registry ##########
def get_steam_path():
    steam_path = ""

    # Get Steam key in registry
    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\\WOW6432Node\\Valve\\Steam") as hkey:
        # Get installation path from key
        steam_path = os.path.normpath(winreg.QueryValueEx(hkey, "installPath")[0])
    
    return steam_path

