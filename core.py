from main import MainApp
import msgpack
import os

# Create class for modding instance ##################################
class ModInstance:
    def __init__(self, app: MainApp, instance: dict):
        self.app = app
        self.instance = instance
        self.name = instance.get('name', "")
        self.mods = instance.get('mods', [])
        self.paths = instance.get('paths', {})
    
    def __repr__(self):
        return "ModInstance"
    
    def get_loadorder(self):
        return self.mods
    
    def create_instance(self, path: str, name: str):
        return
    

# Create class for Vortex stagefiles #################################
class StageFile:
    def __init__(self, path: str):
        self.path = path
        self.data = {}
        self.files = []
        self.mods = []
        self.modfiles = {} # mod: files
    
    def parse_file(self):
        with open(self.path, 'rb') as file:
            data = msgpack.load(file)
        
        self.data = data
        self.files = [file['relPath'] for file in self.data['files']]
    
    def get_modlist(self):
        mods = []
        modfiles = {}
        for file in self.data['files']:
            mod = os.path.join(os.path.dirname(self.path), file['source'])
            if mod not in mods:
                mods.append(mod)
            if modfiles.get(mod, None) is None:
                modfiles[mod] = [os.path.normpath(file['relPath'])]
            else:
                modfiles[mod].append(os.path.normpath(file['relPath']))
        self.mods = mods
        self.modfiles = modfiles
    
    def if_from_mod(self, file: str, mod: str):
        filepath = os.path.normpath(file.split(mod)[1]).strip("\\".strip())
        return filepath in self.modfiles[mod]
    
    def get_mod_by_file(self, path: str):
        path = path.split(os.path.dirname(self.path))[1].strip("\\")
        modname, path = path.split("\\", 1)
        for mod, files in self.modfiles.items():
            if os.path.basename(mod) == modname:
                continue
            elif path in files:
                return os.path.basename(mod)
        else:
            #print(f"{path = }")
            #print(f"{mod = }")
            #print(path in files)
            #print(files)
            return modname
            raise ValueError(f"File '{path}' not found!")
    

# Create class for Vortex instance ###################################
class VortexInstance(ModInstance):
    def __init__(self, app: MainApp, instance: dict):
        super().__init__(app, instance)
        
        self.stagefile = StageFile(self.paths['stagefile'])
        self.stagefile.parse_file()
        self.stagefile.get_modlist()
        self.mods = self.instance['mods'] = self.stagefile.mods
        self.files = self.instance['files'] = self.stagefile.files
        self.unsorted_loadorder = True

    def __repr__(self):
        return "VortexInstance"
            
    def sort_loadorder(self):
        self.app.log.info(f"Creating loadorder with {len(self.mods)} mod(s) from stagefile...")
            
        # Write unsorted loadorder for debbuging purpose to appdata folder
        with open(os.path.join(os.getenv('APPDATA'), self.app.name, 'unsorted_loadorder.txt'), 'w') as file:
            mods = ""
            for mod in self.stagefile.mods:
                mods += "\n" + os.path.basename(mod)
            #mods = mods.strip()
            file.write(f"# This file was automatically generated by Mod Manager Migrator.{mods}")
        
        # Scan mods
        self.app.log.info("Scanning mods...")
        load_order = [os.path.basename(mod) for mod in self.stagefile.mods]
        for c, mod in enumerate(self.stagefile.mods):
            modname = os.path.basename(mod)
            self.app.log.debug(f"Scanning mod '{modname}'... ({c}/{len(self.stagefile.mods)})")
            files = create_folder_list(mod)
            #self.app.log.debug(f"Files: {len(files)}")
            # Create list of mods that overwrite this
            overwriting_mods = []
            for file in files:
                if not self.stagefile.if_from_mod(file, mod):
                    overwriting_mod = self.stagefile.get_mod_by_file(file)
                    if overwriting_mod != modname:
                        overwriting_mods.append(overwriting_mod)
            overwriting_mods = list(set(overwriting_mods)) # Remove duplicates
            if overwriting_mods:
                self.app.log.debug(f"Mod '{modname}' gets overwritten by {overwriting_mods}")

            index = load_order.index(modname)
            if overwriting_mods:
                #self.app.log.debug(f"Sorting mod...")
                self.app.log.debug(f"Old index: {index}")
                for overwriting_mod in overwriting_mods:
                    overwriting_index = load_order.index(overwriting_mod)
                    # Compare indices
                    if index > overwriting_index:
                        index = overwriting_index
                        continue
                if index < 0:
                    index = 0
                self.app.log.debug(f"New index: {index}")

            # Move mod to new index
            load_order.remove(modname)
            load_order.insert(index, modname)
        
        self.app.log.info("Created load order from Vortex deployment file.")
        
        # Write sorted loadorder for debbuging purposes to appdata folder
        with open(os.path.join(os.getenv('APPDATA'), self.app.name, 'sorted_loadorder.txt'), 'w') as file:
            mods = '\n'.join(load_order).strip()
            file.write(f"# This file was automatically generated by Mod Manager Migrator.\n{mods}")
        
        self.loadorder = load_order
        self.unsorted_loadorder = False

        self.app.log.info(f"Created loadorder.")
    
    def get_loadorder(self):
        # Only sort loadorder if not already done
        if self.unsorted_loadorder:
            self.sort_loadorder()

        return super().get_loadorder()
    
    def check_loadorder(self):
        """
        This method is for checking if files in stagefile and loadorder match.
        For debugging purposes!
        """

        print("Checking loadorder...")
        print("Creating stagefile list...")
        stagefile_files = {}
        for file in self.stagefile.data['files']:
            stagefile_files[file['relPath']] = file['source']
        
        print("Creating loadorder list...")
        loadorder_files = {}
        for c, mod in enumerate(self.loadorder):
            print(f"Mod {c}/{len(self.loadorder)}")
            mod = os.path.join(os.path.dirname(self.stagefile.path))
            #files = stagefile.modfiles[mod]
            files = create_folder_list(mod)
            for file in files:
                loadorder_files[file] = os.path.basename(mod)
        
        print("Comparing...")
        different_files = {}
        # Check each file and mod
        for file, mod in stagefile_files.items():
            # If file should come from different mod, add it to list
            if loadorder_files.get(file, mod) != mod:
                different_files[file] = mod
        if different_files:
            print("Found different files:")
            print(different_files)
        else:
            print("Found no differences!")


# Create class for MO2 instance ######################################
class MO2Instance(ModInstance):
    def __repr__(self):
        return "MO2Instance"

    def create_instance(self, path: str, name: str):
        self.app.log.info(f"Creating MO2 instance '{name}' in '{path}'...")
        self.app.log.info(f"Created MO2 instance.")

    @staticmethod
    def get_instances(app: MainApp):
        instances_path = os.path.join(os.getenv('LOCALAPPDATA'), 'ModOrganizer')
        instances = []
        # Check if path exists
        if os.path.isdir(instances_path):
            # Filter for folders and ignore files
            instances = [obj for obj in os.listdir(instances_path) if os.path.isdir(os.path.join(instances_path, obj))]
            app.log.info(f"Found {len(instances)} instance(s).")
        # Show error message otherwise
        else:
            app.log.error("Failed to load instances from ModOrganizer: Found no instances.")
        
        # Return list with found instances
        return instances

# Read folder and save files with relative paths to list #############
def create_folder_list(folder: str):

    files = []

    for root, dirs, _files in os.walk(folder):
        for f in _files:
            files.append(os.path.join(root, f))

    return files
