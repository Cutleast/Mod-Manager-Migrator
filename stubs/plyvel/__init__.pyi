"""
Copyright (c) Cutleast

Original code licensed under MIT License by ysenarath from here:
    https://github.com/ysenarath/plyvel-stubs

Adapted for plyvel-ci for Windows usage and Python>=3.12.
"""

from __future__ import annotations

from types import TracebackType
from typing import Iterator, Optional, overload

class Error(Exception): ...
class IOError(Error): ...
class CorruptionError(Error): ...
class IteratorInvalidError(Error): ...

class WriteBatch:
    def put(self, key: bytes, value: bytes) -> None: ...
    def delete(self, key: bytes) -> None: ...
    def clear(self) -> None: ...
    def write(self) -> None: ...
    def __enter__(self) -> WriteBatch: ...
    def __exit__(
        self,
        exc_type: Optional[type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...

class DB:
    def __init__(
        self,
        name: str,
        create_if_missing: bool = False,
        error_if_exists: bool = False,
        paranoid_checks: bool = False,
        compression: Optional[bool] = None,
        write_buffer_size: Optional[int] = None,
        max_open_files: Optional[int] = None,
        lru_cache_size: Optional[int] = None,
        bloom_filter_bits: Optional[int] = None,
    ) -> None: ...
    def close(self) -> None: ...
    @overload
    def get(self, key: bytes) -> Optional[bytes]: ...
    @overload
    def get[T](self, key: bytes, default: T) -> bytes | T: ...
    def put(self, key: bytes, value: bytes, sync: bool = False) -> None: ...
    def delete(self, key: bytes, sync: bool = False) -> None: ...
    def iterator(
        self,
        *,
        prefix: Optional[bytes] = None,
        start: Optional[bytes] = None,
        stop: Optional[bytes] = None,
        include_start: bool = True,
        include_stop: bool = False,
        reverse: bool = False,
    ) -> Iterator[tuple[bytes, bytes]]: ...
    def range_iterator(
        self, start: Optional[bytes], stop: Optional[bytes]
    ) -> Iterator[tuple[bytes, bytes]]: ...
    def compact_range(
        self, start: Optional[bytes] = None, stop: Optional[bytes] = None
    ) -> None: ...
    def property(self, name: str) -> Optional[str]: ...
    def __enter__(self) -> DB: ...
    def __exit__(
        self,
        exc_type: Optional[type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...
    def write_batch(
        self, transaction: bool = False, sync: bool = False
    ) -> WriteBatch: ...
    def prefixed_db(self, prefix: bytes) -> PrefixedDB: ...

class PrefixedDB:
    def __init__(self, prefix: bytes, db: DB) -> None: ...
    def get(self, key: bytes, default: Optional[bytes] = None) -> Optional[bytes]: ...
    def put(self, key: bytes, value: bytes, sync: bool = False) -> None: ...
    def delete(self, key: bytes, sync: bool = False) -> None: ...
    def write_batch(
        self, transaction: bool = False, sync: bool = False
    ) -> WriteBatch: ...
    def iterator(
        self,
        start: Optional[bytes] = None,
        stop: Optional[bytes] = None,
        include_start: bool = True,
        include_stop: bool = False,
        reverse: bool = False,
    ) -> Iterator[tuple[bytes, bytes]]: ...
    def snapshot(self) -> PrefixedDB: ...
    def prefixed_db(self, prefix: bytes) -> PrefixedDB: ...
