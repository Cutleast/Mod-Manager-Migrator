from main import MainApp
import msgpack
import os
import winreg
import shutil


# Create class for mods ##############################################
class Mod:
    def __init__(self, name: str, files: list):
        self.name = name
        self.files = files
        self.overwriting_mods = []
        self.all_files = []


# Create class for modding instance ##################################
class ModInstance:
    """
    General class for mod manager instances.
    """

    def __init__(self, app: MainApp, instance: dict):
        self.app = app
        self.instance = instance
        self.name = instance.get('name', "")
        self.mods = instance.get('mods', [])
        self.paths = instance.get('paths', {})
        self.size = 0
    
    def __repr__(self):
        return "ModInstance"

    def get_loadorder(self, psignal=None):
        """
        Creates and returns loadorder sorted after index.
        """

        def _sort(mod):
            return mod.index
        
        loadorder = self.mods.copy()
        loadorder.sort(key=_sort)

        return loadorder
    
    def create_instance(self):
        """
        Creates instance files and directories.

        Steps depend on mod manager.
        """

        return
    
    def get_size(self):
        """
        Calculates and returns total size in bytes of all mods.
        """

        return self.size
    
    def import_mod(self, modfolder: str):
        """
        Imports <modfolder> by copying to own mod location.
        
        Parameters:
            modfolder: path to folder with mod files
        """

        return


# Create class for ModOrganizer instance #############################
class MO2Instance(ModInstance):
    """
    Class for ModOrganizer ModInstance. Inherited from ModInstance class.
    """

    def __repr__(self):
        return "MO2Instance"

    def create_instance(self):
        self.app.log.info(f"Creating MO2 instance '{self.name}' in '{self.paths['instance_path']}'...")

        # Create directories
        self.app.log.debug(f"Creating directories...")
        appdata_path = os.path.join(os.getenv('LOCALAPPDATA'), 'ModOrganizer', self.name)
        os.makedirs(appdata_path) # raise exception if instance does already exist
        os.makedirs(self.paths['instance_path'], exist_ok=True)
        os.makedirs(self.paths['download_path'], exist_ok=True)
        os.makedirs(self.paths['mods_path'], exist_ok=True)
        os.makedirs(self.paths['profiles_path'], exist_ok=True)
        os.makedirs(os.path.join(self.paths['profiles_path'], 'Default'), exist_ok=True)
        os.makedirs(self.paths['overwrite_path'], exist_ok=True)
        self.app.log.debug(f"Created instance folders.")

        # Create ini file with instance paths
        instance_path = self.paths['instance_path'].replace('\\', '/')
        download_path = self.paths['download_path'].replace('\\', '/')
        skyrim_path = os.path.join(get_steam_path(), 'steamapps', 'common', 'Skyrim Special Edition').replace('\\', '/')
        with open(os.path.join(appdata_path, 'ModOrganizer.ini'), 'w') as inifile:
            ini = f"""
[General]
gameName=Skyrim Special Edition
selected_profile=@ByteArray(Default)
gamePath={skyrim_path}
version=2.4.4
first_start=true

[Settings]
base_directory={instance_path}
download_directory={download_path}
style=Paper Dark.qss

[PluginPersistance]
Python%20Proxy\\tryInit=false

[recentDirectories]
size=0
""".strip()
            inifile.write(ini)
        self.app.log.debug(f"Created 'ModOrganizer.ini'.")

        # Create profile files
        prof_path = os.path.join(self.paths['profiles_path'], 'Default')
        # Create initweaks.ini
        with open(os.path.join(prof_path, 'initweaks.ini'), 'w') as inifile:
            inifile.write("""[Archive]\nbInvalidateOlderFiles=1""".strip())
        self.app.log.debug("Created 'initweaks.ini'.")

        # Create modlist.txt
        with open(os.path.join(prof_path, 'modlist.txt'), 'w') as file:
            mods = ""
            for mod in self.get_loadorder():
                mods += "\n+" + os.path.basename(mod)
            mods = mods.strip()
            file.write(f"# This file was automatically generated by Mod Organizer.\n{mods}")
        self.app.log.debug("Created 'modlist.txt'.")

        # Copy ini files from User\Documents\My Games\Skyrim Special Edition
        ini_path = self.app.doc_path
        shutil.copy(os.path.join(ini_path, 'Skyrim.ini'), os.path.join(prof_path, 'skyrim.ini'))
        shutil.copy(os.path.join(ini_path, 'SkyrimCustom.ini'), os.path.join(prof_path, 'skyrimcustom.ini'))
        shutil.copy(os.path.join(ini_path, 'SkyrimPrefs.ini'), os.path.join(prof_path, 'skyrimprefs.ini'))
        self.app.log.debug("Copied ini files from Skyrim folder.")

        self.app.log.info(f"Created MO2 instance.")
    
    def import_mod(self, modfolder: str):
        modname = os.path.basename(modfolder)
        shutil.copytree(modfolder, os.path.join(self.paths['mods_path'], modname))
    
    def get_size(self):
        self.app.log.debug(f"Calculating size of MO2 instance...")

        # WORK IN PROGRESS!!
        # Calculate size for each instance subfolder
        # because they can be at different locations

        self.app.log.debug(f"Calculation complete. Instance size: {self.size}")

        return super().get_size()

    @staticmethod
    def get_instances(app: MainApp):
        """
        Creates and returns a list of all ModOrganizer instances at %LOCALAPPDATA%\\ModOrganizer.

        Parameters:
            app: MainApp (for logging)
        """
        instances_path = os.path.join(os.getenv('LOCALAPPDATA'), 'ModOrganizer')
        instances = []
        # Check if path exists
        if os.path.isdir(instances_path):
            # Filter for folders and ignore files
            instances = [obj for obj in os.listdir(instances_path) if os.path.isdir(os.path.join(instances_path, obj))]
            app.log.info(f"Found {len(instances)} instance(s).")
        # Show error message otherwise
        else:
            app.log.error("Failed to load instances from ModOrganizer: Found no instances.")
        
        # Return list with found instances
        return instances


# Create class for Vortex stagefile ##################################
class StageFile:
    def __init__(self, app: MainApp, path: str):
        self.app = app
        self.path = path
        self.dir = os.path.dirname(path)
        self.data = {}
        self.loadorder = []
        self.modfiles = {} # mod: files

        self.parse_file()
        self.get_modlist()
    
    def parse_file(self):
        with open(self.path, 'rb') as file:
            data = msgpack.load(file)
        
        self.data = data
    
    def get_modlist(self):
        loadorder = []
        modfiles = {}
        for file in self.data['files']:
            mod = file['source']
            if mod not in loadorder:
                loadorder.append(mod)
            if mod not in modfiles.keys():
                modfiles[mod] = [file['relPath'].lower()]
            else:
                modfiles[mod].append(file['relPath'].lower())
        
        self.loadorder = loadorder
        self.modfiles = modfiles
    
    def get_mod_by_filename(self, filename: str):
        """
        Returns modname as string or None if nothing is found.
        
        Parameters:
            filename: relative path to file
        """

        #comparisons = f"Searching for file '{filename}'"
        for mod, files in self.modfiles.items():
            for file in files:
                if filename.lower() == file.lower():
                    return mod
                #comparisons += f"\n'{file}': {filename == file}"
        else:
            #with open('comparisons.txt', 'a', encoding='utf8') as compfile:
            #    compfile.write(comparisons)
            self.app.log.warning(f"File '{filename}' not found!")
        
            return None


# Create class for Vortex instance ###################################
class VortexInstance(ModInstance):
    """
    Class for Vortex ModInstance. Inherited from ModInstance class.
    """

    def __init__(self, app: MainApp, instance: dict):
        super().__init__(app, instance)

        self.stagefile = StageFile(self.app, self.paths['stagefile'])
        #self.mods = {mod: {'files': files, 'index': i} for i, (mod, files) in enumerate(self.stagefile.modfiles.items())}
        #self.mods = {mod: Mod(mod, files, i) for i, (mod, files) in enumerate(self.stagefile.modfiles.items())}
        self.mods = [Mod(mod, files) for mod, files in self.stagefile.modfiles.items()]
        self.unsorted = True
    
    def __repr__(self):
        return "VortexInstance"
    
    def sort_loadorder(self, psignal=None):
        self.app.log.info(f"Sorting loadorder with {len(self.mods)} mod(s)...")

        for c, (mod, moddata) in enumerate(self.mods.items()):
            self.app.log.debug(f"Checking mod '{mod}' for overwrites... ({c}/{len(self.mods)})")

            moddata.all_files = create_folder_list(os.path.join(self.stagefile.dir, mod))

            for file in moddata.all_files:
                overwriting_mod = self.stagefile.get_mod_by_filename(file)
                if (overwriting_mod is not None)\
                    and (overwriting_mod != mod)\
                    and (overwriting_mod not in moddata.overwriting_mods):
                    moddata.overwriting_mods.append(overwriting_mod)
            
            if moddata.overwriting_mods:
                old_index = index = moddata.index

                # Get smallest index of all overwriting mods
                index = min([_moddata.index for _mod, _moddata in self.mods.items() if _mod in moddata.overwriting_mods])

                if index < old_index:
                    moddata.index = index
                    self.app.log.debug(f"Moved mod '{mod}' from index {old_index} to {index}.")
        
        self.app.log.info(f"Finalizing loadorder...")
        while different_files := self.check_loadorder():
            for file, mods in different_files.items():
                old_index = self.mods[mods['mod']].index
                new_index = self.mods[mods['overwriting_mod']].index
                if new_index < old_index:
                    self.mods[mod].index = new_index
                    self.app.log.debug(f"Moved mod '{mod}' from index {old_index} to {index}.")
            break
        
        self.app.log.info("Sorting complete.")

        with open('sorted_loadorder.txt', 'w') as file:
            mods = ""
            for mod in super().get_loadorder():
                mods += f"\n+{mod}"
            mods = mods.strip()
            file.write(f"# This file was automatically generated by Mod Organizer.\n{mods}")
    
    def get_loadorder(self, psignal=None):
        if self.unsorted:
            self.unsorted = False
            self.sort_loadorder(psignal)
        
        loadorder = super().get_loadorder(psignal)
        loadorder.reverse()
        return loadorder

    def check_loadorder(self):
        self.app.log.debug(f"Checking loadorder...")
        
        stagefile_files = {} # file: mod
        for mod, files in self.stagefile.modfiles.items():
            for file in files:
                stagefile_files[file] = mod
        
        loadorder_files = {} # file: mod
        loadorder = super().get_loadorder()
        for mod in loadorder:
            moddata = self.mods[mod]
            for file in moddata['all_files']:
                loadorder_files[file] = mod
        
        different_files = {} # file: {'mod': mod, 'overwriting_mod': overwriting_mod}
        for file, mod in loadorder_files.items():
            overwriting_mod = stagefile_files.get(file, None)
            if overwriting_mod is None:
                print(f"File: {file}")
                print(f"Loadorder mod: {mod} ({self.mods[mod]['index']})")
                print(f"Stagefile mod: NOT FOUND!")
                print("-"*50)
                different_files[file] = {'mod': mod, 'overwriting_mod': None}
            elif overwriting_mod != mod:
                print(f"File: {file}")
                print(f"Mod: {mod} ({self.mods[mod]['index']})")
                print(f"Overwritten by: {overwriting_mod} ({self.mods[overwriting_mod]['index']})")
                print("-"*50)
                different_files[file] = {'mod': mod, 'overwriting_mod': overwriting_mod}
        
        self.app.log.info(f"Found {len(different_files)} wrong sorted files.")
        return different_files
    
    def get_size(self):
        self.app.log.debug(f"Calculating size of Vortex instance...")
        
        # Calculate size of staging folder
        #size = get_folder_size(self.paths['staging_folder'])
        size = 0
        for file in self.stagefile.data['files']:
            size += os.path.getsize(os.path.join(self.paths['staging_folder'], file['source'], file['relPath']))

        # Add size of download folder if one is given
        if self.paths['download_path']:
            size += get_folder_size(self.paths['download_path'])

        self.size = size
        self.app.log.debug(f"Calculation complete. Instance size: {get_size(self.size)}")
        return super().get_size()


# Read folder and save files with relative paths to list #############
def create_folder_list(folder, lower=True):
    """
    Creates a list with all files with relative paths to <folder> and returns it.

    Lowers filenames if <lower> is True.
    """
    files = []

    for root, dirs, _files in os.walk(folder):
        for f in _files:
            if f not in ['.gitignore', 'meta.ini']: # check if in blacklist
                path = os.path.join(root, f)
                path = path.removeprefix(f"{folder}\\")
                files.append(path.lower())

    return files

# Define function to round bytes #####################################
def get_size(bytes: int | float, suffix="B"):
    """
    Scale bytes to their proper format; for e.g:
    1253656 => '1.20MB'
    1253656678 => '1.17GB'
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P", "H"]:
        if bytes < factor:
            if f"{bytes:.2f}".split(".")[1] == "00":
                return f"{int(bytes)}{unit}{suffix}"
            else:
                return f"{bytes:.2f}{unit}{suffix}"
        bytes /= factor
    else:
        return str(bytes)

# Define function to calculate folder size
def get_folder_size(start_path: str):
    total_size = 0
    i = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            # skip if it is symbolic link
            if not os.path.islink(fp):
                try:
                    total_size += os.path.getsize(fp)
                except Exception as ex:
                    pass
                i += 1
    return total_size

# Define function get Steam installation path from registry ##########
def get_steam_path():
    steam_path = ""

    # Get Steam key in registry
    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\\WOW6432Node\\Valve\\Steam") as hkey:
        # Get installation path from key
        steam_path = os.path.normpath(winreg.QueryValueEx(hkey, "installPath")[0])
    
    return steam_path

