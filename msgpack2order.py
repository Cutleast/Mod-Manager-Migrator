import msgpack
import os


class StageFile:
    def __init__(self, path: str):
        self.path = path
        self.data = {}
        self.files = []
        self.mods = []
        self.modfiles = {} # mod: files
    
    def parse_file(self):
        with open(self.path, 'rb') as file:
            data = msgpack.load(file)
        
        self.data = data
        self.files = [file['relPath'] for file in self.data['files']]
    
    def get_modlist(self):
        mods = []
        modfiles = {}
        for file in self.data['files']:
            mod = os.path.join(os.path.dirname(self.path), file['source'])
            if mod not in mods:
                mods.append(mod)
            if modfiles.get(mod, None) is None:
                modfiles[mod] = [os.path.normpath(file['relPath'])]
            else:
                modfiles[mod].append(os.path.normpath(file['relPath']))
        self.mods = mods
        self.modfiles = modfiles
    
    def if_from_mod(self, file: str, mod: str):
        filepath = os.path.normpath(file.split(mod)[1]).strip("\\".strip())
        return filepath in self.modfiles[mod]
    
    def get_mod_by_file(self, path: str):
        path = path.split(os.path.dirname(self.path))[1].strip("\\")
        modname, path = path.split("\\", 1)
        for mod, files in self.modfiles.items():
            if os.path.basename(mod) == modname:
                continue
            elif path in files:
                return os.path.basename(mod)
        else:
            #print(f"{path = }")
            #print(f"{mod = }")
            #print(path in files)
            #print(files)
            return modname
            raise ValueError(f"File '{path}' not found!")


# Read folder and save files with relative paths to list #############
def create_folder_list(folder):

    files = []

    for root, dirs, _files in os.walk(folder):
        for f in _files:
            files.append(os.path.join(root, f))

    return files

def vortex2order(stagefile: StageFile):
    #for mod in stagefile.mods:
    #    print(mod)
    with open('unsorted_loadorder.txt', 'w') as file:
        mods = ""
        for mod in stagefile.mods:
            mods += "\n" + os.path.basename(mod)
        file.write(f"# This file was automatically generated by Mod Manager Migrator.\n{mods}")
    print("Scanning mods...")
    load_order = [os.path.basename(mod) for mod in stagefile.mods]
    for c, mod in enumerate(stagefile.mods):
        modname = os.path.basename(mod)
        print(f"Scanning mod '{modname}'... ({c}/{len(stagefile.mods)})")
        #print(f"Scanning mod '{mod}'...")
        files = create_folder_list(mod)
        #print(f"Files: {len(files)}")
        # Create list of mods that overwrite this
        overwriting_mods = []
        for file in files:
            if not stagefile.if_from_mod(file, mod):
                overwriting_mod = stagefile.get_mod_by_file(file)
                if overwriting_mod != modname:
                    overwriting_mods.append(overwriting_mod)
        overwriting_mods = list(set(overwriting_mods)) # Remove duplicates
        if overwriting_mods:
            print(f"Mod '{modname}' gets overwritten by {overwriting_mods}")

        index = load_order.index(modname)
        if overwriting_mods:
            #print(f"Sorting mod...")
            print(f"Old index: {index}")
            for overwriting_mod in overwriting_mods:
                overwriting_index = load_order.index(overwriting_mod)
                # Compare indices
                if index > overwriting_index:
                    index = overwriting_index
                    continue
            if index < 0:
                index = 0
            print(f"New index: {index}")

        # Move mod to new index
        load_order.remove(modname)
        load_order.insert(index, modname)
    
    print("Created load order from Vortex deployment file.")
    
    with open('sorted_loadorder.txt', 'w') as file:
        mods = '\n'.join(load_order)
        file.write(f"# This file was automatically generated by Mod Manager Migrator.\n{mods}")

    return load_order

def check_loadorder(stagefile: StageFile, loadorder: list):
    print("Checking loadorder...")
    print("Creating stagefile list...")
    stagefile_files = {}
    for file in stagefile.data['files']:
        stagefile_files[file['relPath']] = file['source']
    
    print("Creating loadorder list...")
    loadorder_files = {}
    for c, mod in enumerate(loadorder):
        print(f"Mod {c}/{len(loadorder)}")
        mod = os.path.join(os.path.dirname(stagefile.path), mod)
        #files = stagefile.modfiles[mod]
        files = create_folder_list(mod)
        for file in files:
            loadorder_files[file] = os.path.basename(mod)
    
    print("Comparing...")
    different_files = {stagefile_mod: stagefile_files[stagefile_mod] for stagefile_mod in stagefile_files if stagefile_mod in loadorder_files and stagefile_files[stagefile_mod] == loadorder_files[stagefile_mod]}
    if different_files:
        print("Found different files:")
        print(different_files)
    else:
        print("Found no differences!")

if __name__ == '__main__':
    filename = "C:\\Modding\\Skyrim\\Vortex\\vortex.deployment.msgpack"
    stagefile = StageFile(filename)
    stagefile.parse_file()
    stagefile.get_modlist()

    loadorder = vortex2order(stagefile)

    check_loadorder(stagefile, loadorder)